#include <iostream>

/**
    This method calculates the Greatest Common Divisor (GCD) of a pair of numbers

    The GCD is calculated by the 'Euclidian Algorithm' which basically does the following;

    - We can recursively shrink the second number, in this case b and then swap the inputs.
    - when b is 0, we have found the gcd and can return it (will be in the a section)

    This also works for negative numbers, see https://proofwiki.org/wiki/GCD_for_Negative_Integers
    for proofs that gcd(a,b) = gcd(a,|b|) and other variations.
 
*/
int GCD(int a, int b){
    // abs value of numbers to ensure negatives dont break things.
    if (a<0) {a*=-1;}
    if (b<0) {b*=-1;}

    int out = -1;

    // if we have a 0 input, the gcd is going to be the other input.
    if (b == 0){
        return a;
    } else {
        // If we actually have two numbers, 
        // recursively shrink the second input using modulus
        out = GCD(b, a%b);
    }

    return out;
}

int main() {
    // Test the function with some example values
    std::cout << GCD(12, 24) << std::endl; // 12
    std::cout << GCD(1, 2) << std::endl; // 1
    std::cout << GCD(-3, 9) << std::endl; // -3 
    std::cout << GCD(8, 13) << std::endl; // 1
    std::cout << GCD(256, 2) << std::endl; // 2
    std::cout << GCD(2, 256) << std::endl; // 2
}
#include <iostream>

// convert the number to a string, then use 2 pointers to verify if both halfs are identical
// if not, we dont have a palindrome number

bool palNum( int num ){
    // convert number to a string so we can index it.
    std::string str = std::to_string(num);

    // iterate over chars in the string, if every index is the same as the mirrored index
    // we can return true, since we have a palindrome
    for (int i=0; i<str.size()-1; i++){
       if (str[i] != str[str.size()-1-i]){ return false; } 
    }

    return true;

}

int main() {
    int in;

    std::cout << "Input Number: ";
    std::cin >> in;

    if (palNum(in)){
        std::cout << "Is a palindrome" << std::endl;
    } else {
        std::cout << "Isn't a palindrome" << std::endl;
    }

    return 0;
}


#include <iostream>

/**
 * @brief Function for calculating x^y in O(Log n)
 *
 * This function returns a float since negative powers can be calculated as 1 / x^y (if y is negative)
 *
 * @param x the base
 * @param y the power
 * @return the output as a float.
 */
float powFun(int x, int y){

    // power of 0 is always 1
    if (y == 0){ return 1; }

    // Negative powers result in division
    if (y < 0){
        if (y == -1){ return x; }
        return 1 / powFun(x, y*-1);

    } else {
        // Calculate the power recursively, decreasing the power each iteration. Results in a O(log n) computation time, where n = y
        if (y == 1){ return x; }
        return x * powFun(x, y-1);
    }
}

int main() {
    int x, y;
    std::cout << "Input number for x: ";
    std::cin >> x;
    std::cout << "Input number for y: ";
    std::cin >> y;

    float out = powFun(x, y);
    // return a floating point output for values under 0
    // these are caused by negative powers, resulting in fractions / decimal answers
    std::cout << "Output equals: " << out << std::endl;
    return 0;
}
#include <iostream>

/**
powTwo takes an input x and checks if it is a power of two

Powers of two are always represented as one bit in binary.
eg: 00001000 (base 2) = 8 (base 10)

so we can check if the number & the inverse of the number -1 is true
eg:

1000 -> number
0111 -> number - 1
1000 -> inverse of number - 1

1000 & 1000 = true, 8 is a power of 2
*/
bool powTwo(int x){
    return x && !(x & (x - 1));
}

int main() {
    int x;
    std::cout << "Input number for x: ";
    std::cin >> x;
    
    if (powTwo(x)){
        std::cout << x << " is a power of two." << std::endl;
    } else {
        std::cout << x << " is not a power of two." << std::endl;
    }

    return 0;
}
#include <iostream>


/**

  This function takes an input integer and reverses the numbers in the integer.
  Numbers will be outputted to standard output in this file, but the function itself returns the true negative value without padding

  Example input: 12345
  Example reversed output: 54321

  For numbers ending in 0, the stdout contains a leftpadded 0, the function does not (since it returns integer).

  Example input: -420
  Example reversed output: -024
  Example actual value output: -24

*/
int revInt(int in){

    int out = 0;
    
    // if number is negative, convert to positive and manually add minus sign.
    bool pos = (in >= 0);
    if (!pos) {
        in *= -1;
        // write a minus sign so numbers ending in 0 get printed right.
        std::cout << "-";
    }

    // recursively get the first number (rightmost), add to out and do out*10.
    // use mod 10 and divide to move numbers across from input
    
    while (in>0){
        int temp = in % 10; // number on right
        out *= 10;
        out += temp; // put in temp
        std::cout << temp;
        in /= 10; // move input right
    }

    std::cout << "" << std::endl;

    // we now have a reversed integer, carry over sign from input and return
    if (!pos){ out *= -1; }

    // this output is the actual negative number with no 0 padding on the left.
    return out;
}

int main() {
    
    // run the function for multiple numbers to test the outputs

    int input;
    std::cout << "Input a number to reverse: ";
    std::cin >> input;
    std::cout << "Reversed Number: ";
    int x = revInt(input);
    std::cout << "Actual Value: " << x << std::endl;

    /*
    revInt(12345);
    revInt(54321);
    revInt(-123);
    revInt(-420);
    revInt(1337);
    revInt(10105);
    */
}

